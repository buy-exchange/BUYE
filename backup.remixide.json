{
  "sol:LibSafeMath.sol": "pragma solidity ^0.5.10;\r\n\r\n/**\r\n * @title SafeMath library\r\n * @dev throw on error!\r\n */\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        \r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}",
  "config-v0.8:.remix.config": "{\"terminal-top-offset\":170,\"settings/always-use-vm\":true,\"settings/theme\":\"Flatly\",\"currentFile\":\"browser/Buypay.sol\",\"autoCompile\":true}",
  "sol:LibRoles.sol": "pragma solidity ^0.5.10;\n\n/**\n * @title Permission Roles Define\n * @dev based on openzeppelin-contract/access(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Roles.sol)\n */ \n \n library Roles {\n     struct Role {\n         mapping (address => bool) bearer;\n     }\n     \n     /**\n      * @dev role adding\n      * \n      * @param role struct Role\n      * @param account added address\n      */\n     function add(Role storage role, address account) internal {\n         require(!has(role, account), \"Roles : account already has role\");\n         role.bearer[account] = true;\n     }\n     \n     /**\n      * @dev role removing\n      * \n      * @param role struct role\n      * @param account removed address\n      */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles : account does not have role\");\n        role.bearer[account] = false;\n    }\n     \n    /**\n     * @dev check Role\n     * \n     * @param role struct role\n     * @param account checking address\n     */\n     function has(Role storage role, address account) internal view returns (bool) {\n         require(account != address(0), \"Roles : account is Zero\");\n         return role.bearer[account];\n     }\n }",
  "sol:StandardToken.sol": "pragma solidity ^0.5.10;\n\nimport \"./Ownable.sol\";\nimport \"./LibSafeMath.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @title Standard Token Contract\n * @dev implements of {ERC20} Token\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based oncode By Tether(https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)\n */\n \ncontract StandardToken is Ownable, IERC20 {\n    using SafeMath for uint256;\n    \n    uint256 internal _totalSupply;\n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowed;\n    \n    uint256 private MAX_ALLOWED_UINT = 2 ** 256 - 1;\n    \n    uint256 internal basisPointRate = 0;\n    uint256 internal maximumFee = 0;\n    \n    /**\n     * @dev Fix for the {ERC20} short address attack\n     */\n    modifier onlyPayloadSize(uint256 size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address _account) public view returns(uint256) {\n        return _balances[_account];\n    }\n    \n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n        uint256 fee = (_value.mul(basisPointRate)).div(10000);\n        \n        if(fee > maximumFee) { fee = maximumFee; }\n        \n        uint256 sendAmount = _value.sub(fee);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(_value);\n        _balances[_to] = _balances[_to].add(sendAmount);\n        \n        if(fee > 0) {\n            _balances[_owner] = _balances[_owner].add(fee);\n            emit Transfer(msg.sender, _owner, fee);\n        }\n        \n        emit Transfer(msg.sender, _to, sendAmount);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\n        uint256 _allowance = _allowed[_from][msg.sender];\n        \n        uint256 fee = (_value.mul(basisPointRate)).div(10000);\n        \n        if (fee > maximumFee) { fee = maximumFee; }\n        \n        if (_allowance < MAX_ALLOWED_UINT) {\n            _allowed[_from][msg.sender] = _allowance.sub(_value);\n        }\n        \n        uint256 sendAmount = _value.sub(fee);\n        \n        _balances[_from] = _balances[_from].sub(_value);\n        _balances[_to] = _balances[_to].add(sendAmount);\n        \n        if(fee >0) {\n            _balances[_owner] = _balances[_owner].add(fee);\n            emit Transfer(_from, _owner, fee);\n        }\n        \n        emit Transfer(_from, _to, sendAmount);\n        return true;\n    }\n    \n    function allowance(address _tokenOwner, address _tokenSpender) public view returns (uint256) {\n        return _allowed[_tokenOwner][_tokenSpender];\n    }\n    \n    function approve(address _spender, uint256 _amount) public onlyPayloadSize(2 * 32) returns (bool) {\n        /**\n         * @dev consider error case\n         * @dev https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n         */\n        require(!((_amount != 0) && (_allowed[msg.sender][_spender] != 0 )), \"StandardToken : allowance is Not Zero and amount is Not Zero\");\n        \n        _allowed[msg.sender][_spender] = _amount;\n        \n        emit Approval(msg.sender, _spender, _amount);\n        \n        return true;\n    }\n}\n\n/**\n * @title Legacy Token Interface\n * @dev Legacy function\n */\ncontract UpgradedToken is StandardToken {\n    /**\n     * @dev called by the legacy contract\n     * @dev ensure msg.sender to be the contract address\n     */\n    function transferByLegacy(address _from, address _to, uint256 _amount) public returns (bool);\n    function transferFromByLegacy(address _sender, address _from, address _to, uint256 _amount) public returns (bool);\n    function approveByLegacy(address _from, address _spender, uint256 _value) public returns (bool);\n}",
  "sol:IERC20.sol": "pragma solidity ^0.5.10;\n\n/**\n * @title {ERC20} Interface\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    \n    function balanceOf(address _account) external view returns(uint256);\n    \n    function transfer(address _to, uint256 amount) external returns (bool);\n    \n    function allowance(address _owner, address _spender) external view returns (uint256);\n    \n    function approve(address _spender, uint256 _amount) external returns (bool);\n    \n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}",
  "workspace": "[\"contextualListener\",\"terminal\",\"contentImport\",\"theme\",\"editor\",\"fileManager\",\"compilerMetadata\",\"compilerArtefacts\",\"network\",\"offsetToLineColumnConverter\",\"mainPanel\",\"menuicons\",\"home\",\"sidePanel\",\"pluginManager\",\"fileExplorers\",\"settings\",\"solidity\",\"udapp\",\"debugger\"]",
  "sol:Mint.sol": "pragma solidity ^0.5.10;\n\nimport \"./LibRoles.sol\";\nimport \"./Ownable.sol\";\n\n/**\n * @title MinterRole\n * @dev Minter Permissions\n * @dev based openzeppelin-contracts/access/Roles/Mint(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/roles/MinterRole.sol)\n * @dev Minter != Owner\n */ \n\ncontract MinterRole is Ownable {\n    using Roles for Roles.Role;\n    \n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n    \n    Roles.Role private _minter;\n    \n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n    \n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"Minter : Caller does not have minter Role\");\n        _;\n    }\n    \n    function isMinter(address _account) public view returns(bool) {\n        return _minter.has(_account);\n    }\n    \n    function _addMinter(address _account) internal {\n        _minter.add(_account);\n        emit MinterAdded(_account);\n    }\n    \n    function _removeMinter(address _account) internal {\n        _minter.remove(_account);\n        emit MinterRemoved(_account);\n    }\n    \n    /**\n     * @dev minter role account add, require minter permissions\n     */ \n    function addMinter(address _account) public onlyOwner {\n        _addMinter(_account);\n    }\n    \n    /**\n     * @dev minter role account remove, require minter permissions\n     */\n    function removeMinter(address _account) public onlyOwner {\n        _removeMinter(_account);\n    }\n}",
  "sol:Ownable.sol": "pragma solidity ^0.5.10;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and basic authorization\n */\n \n contract Ownable {\n     address internal _owner;\n     \n     constructor () internal {\n        _owner = msg.sender;\n     }\n     \n    function isOwner() internal view returns(bool) {\n        return msg.sender == _owner;\n    }\n     \n     modifier onlyOwner() {\n         require(isOwner(), \"Ownable : sender is not **Owner**\");\n         _;\n     }\n }",
  "sol:Pause.sol": "pragma solidity ^0.5.10;\n\nimport \"./LibRoles.sol\";\nimport \"./Ownable.sol\";\n\n/**\n * @title PauserRole\n * @dev Minter Permissions\n * @dev based openzeppelin-contracts/access/Roles/Mint(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/roles/PauserRole.sol)\n */ \n\ncontract PauserRole is Ownable {\n    using Roles for Roles.Role;\n    \n    event PauserAdd(address indexed account);\n    event PauserRemove(address indexed account);\n    \n    Roles.Role private _pauser;\n    \n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n    \n    modifier onlyPauser() {\n        require(isPauser(msg.sender));\n        _;\n    }\n    \n    function isPauser(address _account) public view returns (bool) {\n        return _pauser.has(_account);\n    }\n    \n    function _addPauser(address _account) internal {\n        _pauser.add(_account);\n        emit PauserAdd(_account);\n    }\n    \n    function _removePauser(address _account) internal {\n        _pauser.remove(_account);\n        emit PauserRemove(_account);\n    }\n    \n    /**\n     * @dev Pause Rule Add, require Pause Permission\n     */\n     function addPauser(address _account) public onlyOwner {\n         _addPauser(_account);\n     }\n     \n     /**\n      * @dev Pause Role Remove, require Pause Permission\n      */ \n      function removePauser(address _account) public onlyOwner {\n          _removePauser(_account);\n      }\n}\n\n/**\n * @title Pausable\n * @dev  Pausable Function Implements\n */\n\ncontract Pausable is PauserRole {\n    event Paused();\n    event Unpaused();\n    \n    bool private _paused;\n    \n    constructor () internal {\n        _paused = false;\n    }\n    \n    function paused() public view returns (bool) {\n        return _paused;\n    }\n    \n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable : paused\");\n        _;\n    }\n    \n    modifier whenPaused() {\n        require(_paused, \"Pausable : not paused\");\n        _;\n    }\n    \n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused();\n    }\n    \n    function unpause() public onlyPauser whenPaused{\n        _paused = false;\n        emit Unpaused();\n    }\n}",
  "sol:Blacklist.sol": "pragma solidity ^0.5.10;\n\nimport \"./LibRoles.sol\";\nimport \"./Ownable.sol\";\nimport \"./StandardToken.sol\";\n\n/**\n * @dev BlackRole\n * @dev BlackList Managment Permission\n * @dev Based On openzeppelin-contracts/access/roles/Minter(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/roles/MinterRole.sol)\n */\n \n contract BlackRole is Ownable {\n    using Roles for Roles.Role;\n     \n    event BlackListManagerAdded(address indexed account);\n    event BlackListManagerRemoved(address indexed account);\n    \n    Roles.Role private _listManager;\n    \n    constructor () internal {\n        _addListManager(msg.sender);\n    }\n    \n    modifier onlyListManager() {\n        require(isListManager(msg.sender), \"BlackRole : Caller does not have List Magagement\");\n        _;\n    }\n    \n    function isListManager(address _account) public view returns (bool) {\n        return _listManager.has(_account);\n    }\n    \n    function _addListManager(address _account) internal {\n        _listManager.add(_account);\n        emit BlackListManagerAdded(_account);\n    }\n    \n    function _removeListManager(address _account) internal {\n        _listManager.remove(_account);\n        emit BlackListManagerRemoved(_account);\n    }\n    \n    function addListManager(address _account) public  onlyOwner {\n        _addListManager(_account);\n    }\n    \n    function removeListManager(address _account) public onlyOwner {\n        _removeListManager(_account);\n    }\n }\n \n /**\n  * @title BlackList\n  */ \n \n contract BlackList is BlackRole, StandardToken {\n     /**\n      * @dev Blacklist value\n      */\n    mapping ( address => bool ) public isBlackListed;\n    \n\n    function addBlackList(address _evilUser) public onlyListManager {\n        isBlackListed[_evilUser] = true;\n        emit AddedBlackList(_evilUser);\n    }\n    \n    function removeBlackList(address _clearUser) public onlyListManager {\n        isBlackListed[_clearUser] = false;\n        emit RemoveBlackList(_clearUser);\n    }\n    \n    /**\n     * @dev if user is Black, user's balace is Malicious balance\n     * @dev then user's balance is bunning!\n     */\n    function destroyBlackFund(address _user) public onlyListManager {\n        require(isBlackListed[_user], \"BlackList : User is Cleared User\");\n        \n        uint256 blackFund = balanceOf(_user);\n        _balances[_user] = 0;\n        _totalSupply -= blackFund;\n        emit DestroyBlackFund(_user, blackFund);\n    }\n    \n    event AddedBlackList(address _user);\n    event RemoveBlackList(address _user);\n    event DestroyBlackFund(address _user, uint256 _balance);\n}",
  "sol:Buypay.sol": "pragma solidity ^0.5.10;\n\nimport \"./StandardToken.sol\";\nimport \"./Pause.sol\";\nimport \"./Mint.sol\";\nimport \"./Blacklist.sol\";\nimport \"./Ownable.sol\";\n\n/**\n * @title BuyPAY Token \n * @dev Inheritance Ownable, MinterRole, Pausable, StandardToken, BlackList;\n * @dev Submiited for verification at 2019-10-08\n */\n\n\ncontract BuyPayToken is Ownable, MinterRole, Pausable, BlackRole, StandardToken, BlackList {\n    string public name;\n    string public symbol;\n    string public desc;\n    \n    uint256 public decimals;\n    \n    address public upgradedAddress;\n    \n    bool private deprecated;\n    \n    /**\n     * @dev constructor inital value\n     * @dev All token are deposited to the owner's address\n     * \n     * @param _initialSupply Initial Supply of the this contract\n     * @param _name Token Name\n     * @param _symbol Token symbol\n     * @param _desc Token Description\n     * @param _decimals Token Decimals\n     */\n    constructor (uint256 _initialSupply, string memory _name, string memory _symbol, string memory _desc, uint256 _decimals) public {\n        _totalSupply = _initialSupply;\n        name = _name;\n        symbol = _symbol;\n        desc = _desc;\n        decimals = _decimals;\n        _balances[_owner] = _initialSupply;\n        deprecated = false;\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        if (deprecated) {\n            return StandardToken(upgradedAddress).totalSupply();\n        } else {\n            return super.totalSupply();\n        }\n    }\n    \n    function balanceOf(address _account) public view returns (uint256) {\n        if (deprecated) {\n            return StandardToken(upgradedAddress).balanceOf(_account);\n        } else {\n            return super.balanceOf(_account);\n        }\n    }\n    \n    function transfer(address _to, uint256 _amount) public whenNotPaused returns (bool) {\n        require(!isBlackListed[msg.sender], \"BuyPayToken : Sender is BlackList\");\n        \n        if (deprecated) {\n            return UpgradedToken(upgradedAddress).transferByLegacy(msg.sender, _to, _amount);\n        } else {\n            return super.transfer(_to, _amount);\n        }\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _amount) public whenNotPaused returns (bool) {\n        require(!isBlackListed[msg.sender], \"BuyPayToken : Sender is BlackList\");\n        \n        if (deprecated) {\n            return UpgradedToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _amount);\n        } else {\n            return super.transferFrom(_from, _to, _amount);\n        }\n    }\n    \n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        if (deprecated) {\n            return UpgradedToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _amount);\n        } else {\n            return super.approve(_spender, _amount);\n        }\n    }\n    \n    function allowance(address _tokenOwner, address _tokenSpender) public view returns (uint256) {\n        if (deprecated) {\n            return StandardToken(upgradedAddress).allowance(_tokenOwner, _tokenSpender);\n        } else {\n            return super.allowance(_tokenOwner, _tokenSpender);\n        }\n    }\n    \n    /**\n     * @dev this contract is deprecate\n     */\n    function deprecate(address _upgradedAddress) public onlyOwner {\n        deprecated = true ;\n        upgradedAddress = _upgradedAddress;\n        emit Deprecate(_upgradedAddress);\n    }\n    \n    /**\n     * @dev set Fee, Not Ethereum Gas!\n     * @dev BasisPoint is ratio and new MaxFee is Amount\n     * @dev if fee (calculated BasisPoint) over maximumFee, fee is maximumFee implements\n     */\n    function setFeeRate(uint256 newBasisPoints, uint256 newMaxFee) public onlyOwner {\n        require(newBasisPoints < 20 , \"BuyPayToken : BasisPoint is Bigger\");\n        require(newMaxFee < 50, \"BuyPayToken : MaxFee is Bigger\");\n        \n        basisPointRate = newBasisPoints;\n        maximumFee = newMaxFee.mul(10 ** decimals);\n        \n        emit FeeRate(newBasisPoints, newMaxFee);\n    }\n    \n    /**\n     * @dev get Fee, Not Ethereum Gas!\n     * @dev returns Current Fee Rate and maximumFee\n     */\n     function getFeeRate() public view returns (uint256, uint256) {\n         return ( basisPointRate, maximumFee);\n     }\n    \n    /**\n     * @dev Extension of {ERC20} \n     * @dev deposited into the owner's address\n     * @param _amount Number of tokens to be mint\n     */\n    function mint(uint256 _amount) public onlyMinter {\n        require(_totalSupply + _amount > _totalSupply, \"BuyPayToken : incresess Token Fail(TotalSupply)\");\n        require(_balances[_owner] + _amount > _balances[_owner], \"BuyPayToken :incresess Token Fail (Hold Amount) \");\n        \n        _balances[_owner] = _balances[_owner].add(_amount);\n        _totalSupply =  _totalSupply.add(_amount);\n        \n        emit Mint(_amount);\n    }\n    \n    /**\n     * @dev Extension of {ERC20}\n     * @dev withdrawn from owner's address\n     * @dev _amount Number of tokens to be burn\n     */\n    \n    function burn(uint256 _amount) public onlyMinter {\n        require(_totalSupply >= _amount, \"BuyPayToken : amount is Over TotalSupply\");\n        require(_balances[_owner] >= _amount, \"BuyPayToken : Amount greater than the token held by the owner\");\n        \n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[_owner] = _balances[_owner].sub(_amount);\n        \n        emit Burn(_amount);\n    }\n    \n    event Mint(uint256 amount);\n    event Burn(uint256 amount);\n    \n    event Deprecate(address newAddress);\n    event FeeRate(uint256 feeBasisPoints, uint256 maxFee);\n}"
}